> This file contains the generic templates to use for properties of particular types.

> !# @Namespace = lib
> !# @Exports = missingCondition, missingPriority, helpCondition

> This is to provide consistent line endings in templates using Windows standard
# EOL
-\n

# welcome
- Welcome!

# propertyName(property)
- ${template(`${property}_Name`)}

# propertyValue(property, val)
- ${template(`${property}_Value`, val)}

# entityValue(property, val)
- ${template(`${property}Entity_Value`, val)}

# value(val)
- ${complexValue(val, null)}

> Display a value handling arrays and objects and leaf display template
# complexValue(val, leaf)
- IF: ${isArray(val)}
- [${join(foreach(val, elt, complexValue(elt, leaf)), ', ')}]
- ELSEIF: ${isObject(val)}
- {${join(foreach(indicesAndValues(val), elt, `${elt.index}: ${complexValue(elt.value, leaf)}`), ', ')}}
- ELSEIF: ${val}
- ${if(leaf, template(leaf, val), val)}
- ELSE:
- no value

# publicProperties
-${dialogClass.schema.$public}

# requiredProperties
- IF: ${count(dialogClass.schema.required) > 0}
- Required properties include: ${join(foreach(dialogClass.schema.required, property, propertyName(property)), ',')}
- ELSE:
- 

# optionalProperties
- IF: ${add(count(dialogClass.schema.required),count(dialogClass.schema.$expectedOnly)) < count(dialogClass.schema.properties)}
- Optional properties include: ${join(foreach(where(dialogClass.schema.properties, property, !contains(dialogClass.schema.required, property) && !contains(dialogClass.schema.$expectedOnly, property)), property, propertyName(property)), ', ')}${EOL()}
- ELSE:
- 

# possibleValues(property)
- ${foreach(dialogClass.schema.properties[property].enum, enum, propertyValue(property, enum))}

# possibleArrayValues(property)
- ${foreach(dialogClass.schema.properties[property].items.enum, enum, propertyValue(property, enum))}

# possibleValuesList(property)
- [${join(possibleValues(property), ', ')}]

# confirmationText(property, val)
- IF: ${contains($expectedProperties, property)}
    - ${template(if(dialog[property], `${property}_ExpectedSetConfirmation`, `${property}_ExpectedReplaceConfirmation`), val)}
- ELSE:
    - ${template(if(dialog[property], `${property}_UnexpectedReplaceConfirmation`, `${property}_UnexpectedReplaceConfirmation`), val)}

# cancelPrompt
- Do you want to end the conversation? (yes/no)

# changePropertyPrompt
- Is there any property you want to change? (no or the property name)

# choosePropertyPrompt
- Which property do you want to change?

# notUnderstood
- Sorry, I do not understand ${join(foreach(turn.unrecognizedtext, chunk, `'${chunk}'`), ' or ')}

>
> FUNCTIONS, not text
> TODO: These are not currently wired up because triggers don't pick them up.
# shouldPrompt(propertyName)
- ${!dialog[propertyName] || $PropertyToChange == `${propertyName}`}

# promptPriority(propertyName)
- ${indexOf(dialog.requiredProperties, propertyName)}

# missingPriority(property)
- ${indexOf(dialog.requiredProperties, property)}

# helpCondition()
- ${$retries > 0 && $lastIntent != 'Help'}